{"ast":null,"code":"'use strict';\n/* global fetch, btoa, Headers */\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\emmanuelle.aboaf\\\\Documents\\\\GitHub\\\\speech-to-text\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nconst core = require('./core');\n\nclass StatusError extends Error {\n  constructor(res, ...params) {\n    super(...params);\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, StatusError);\n    }\n\n    this.name = 'StatusError';\n    this.message = res.statusMessage;\n    this.statusCode = res.status;\n    this.res = res;\n    this.json = res.json.bind(res);\n    this.text = res.text.bind(res);\n    this.arrayBuffer = res.arrayBuffer.bind(res);\n    let buffer;\n\n    const get = () => {\n      if (!buffer) buffer = this.arrayBuffer();\n      return buffer;\n    };\n\n    Object.defineProperty(this, 'responseBody', {\n      get\n    }); // match Node.js headers object\n\n    this.headers = {};\n\n    for (const [key, value] of res.headers.entries()) {\n      this.headers[key.toLowerCase()] = value;\n    }\n  }\n\n}\n\nconst mkrequest = (statusCodes, method, encoding, headers, baseurl) => /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (_url, body, _headers = {}) {\n    _url = baseurl + (_url || '');\n    let parsed = new URL(_url);\n    if (!headers) headers = {};\n\n    if (parsed.username) {\n      headers.Authorization = 'Basic ' + btoa(parsed.username + ':' + parsed.password);\n      parsed = new URL(parsed.protocol + '//' + parsed.host + parsed.pathname + parsed.search);\n    }\n\n    if (parsed.protocol !== 'https:' && parsed.protocol !== 'http:') {\n      throw new Error(`Unknown protocol, ${parsed.protocol}`);\n    }\n\n    if (body) {\n      if (body instanceof ArrayBuffer || ArrayBuffer.isView(body) || typeof body === 'string') {// noop\n      } else if (typeof body === 'object') {\n        body = JSON.stringify(body);\n        headers['Content-Type'] = 'application/json';\n      } else {\n        throw new Error('Unknown body type.');\n      }\n    }\n\n    _headers = new Headers({ ...(headers || {}),\n      ..._headers\n    });\n    const resp = yield fetch(parsed, {\n      method,\n      headers: _headers,\n      body\n    });\n    resp.statusCode = resp.status;\n\n    if (!statusCodes.has(resp.status)) {\n      throw new StatusError(resp);\n    }\n\n    if (encoding === 'json') return resp.json();else if (encoding === 'buffer') return resp.arrayBuffer();else if (encoding === 'string') return resp.text();else return resp;\n  });\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = core(mkrequest);","map":{"version":3,"sources":["C:/Users/emmanuelle.aboaf/Documents/GitHub/speech-to-text/node_modules/bent/src/browser.js"],"names":["core","require","StatusError","Error","constructor","res","params","captureStackTrace","name","message","statusMessage","statusCode","status","json","bind","text","arrayBuffer","buffer","get","Object","defineProperty","headers","key","value","entries","toLowerCase","mkrequest","statusCodes","method","encoding","baseurl","_url","body","_headers","parsed","URL","username","Authorization","btoa","password","protocol","host","pathname","search","ArrayBuffer","isView","JSON","stringify","Headers","resp","fetch","has","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n/* global fetch, btoa, Headers */\nconst core = require('./core')\n\nclass StatusError extends Error {\n  constructor (res, ...params) {\n    super(...params)\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, StatusError)\n    }\n\n    this.name = 'StatusError'\n    this.message = res.statusMessage\n    this.statusCode = res.status\n    this.res = res\n    this.json = res.json.bind(res)\n    this.text = res.text.bind(res)\n    this.arrayBuffer = res.arrayBuffer.bind(res)\n    let buffer\n    const get = () => {\n      if (!buffer) buffer = this.arrayBuffer()\n      return buffer\n    }\n    Object.defineProperty(this, 'responseBody', { get })\n    // match Node.js headers object\n    this.headers = {}\n    for (const [key, value] of res.headers.entries()) {\n      this.headers[key.toLowerCase()] = value\n    }\n  }\n}\n\nconst mkrequest = (statusCodes, method, encoding, headers, baseurl) => async (_url, body, _headers = {}) => {\n  _url = baseurl + (_url || '')\n  let parsed = new URL(_url)\n\n  if (!headers) headers = {}\n  if (parsed.username) {\n    headers.Authorization = 'Basic ' + btoa(parsed.username + ':' + parsed.password)\n    parsed = new URL(parsed.protocol + '//' + parsed.host + parsed.pathname + parsed.search)\n  }\n  if (parsed.protocol !== 'https:' && parsed.protocol !== 'http:') {\n    throw new Error(`Unknown protocol, ${parsed.protocol}`)\n  }\n\n  if (body) {\n    if (body instanceof ArrayBuffer ||\n      ArrayBuffer.isView(body) ||\n      typeof body === 'string'\n    ) {\n      // noop\n    } else if (typeof body === 'object') {\n      body = JSON.stringify(body)\n      headers['Content-Type'] = 'application/json'\n    } else {\n      throw new Error('Unknown body type.')\n    }\n  }\n\n  _headers = new Headers({ ...(headers || {}), ..._headers })\n\n  const resp = await fetch(parsed, { method, headers: _headers, body })\n  resp.statusCode = resp.status\n\n  if (!statusCodes.has(resp.status)) {\n    throw new StatusError(resp)\n  }\n\n  if (encoding === 'json') return resp.json()\n  else if (encoding === 'buffer') return resp.arrayBuffer()\n  else if (encoding === 'string') return resp.text()\n  else return resp\n}\n\nmodule.exports = core(mkrequest)\n"]},"metadata":{},"sourceType":"script"}